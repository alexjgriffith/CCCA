#' Stacked Contribution
#'
._stackedContrib<-function(data,command="hist",tags=c(FALSE),n=3,steps=40,
                           swapFun=function(string)string,sum=TRUE,colourOveride=NULL,blank=NULL){
    x<-0
    ## Recursivly finds the union of a list of logicals
    ors<-function(inList){
        l<-length(inList)
        if(l==0)
            return(NULL)
        if(l==1)
            return(inList[[1]])
        if(l==2)
            return(inList[[1]] | inList[[2]])
        if(l>2){
            ltemp<-append(list(inList[[1]] | inList[[2]]),inList[3:l])
            return ( ors(ltemp))
        }
    }
    ## Takes a character with some seperation value and applies a
    ## transformation function to the split values
    ## swapLevel :: String -> Function [String] -> String -> String
    swapLevel<-function(inChars,changeChars,split="-"){    
        paste(sapply(strsplit(inChars,split),changeChars),collapse=split)
    }

    ## Returns a function that Generates an upper and lower
    ## bound of n standard deviations from the mean of x
    ## ( a var to be passed in)
    ## upDown :: Numeric -> Function [Numeric]
    upDown<-function(n){
        c(function(x){mean(x)+sqrt(stats::var(x))*n},
          function(x){mean(x)-sqrt(stats::var(x))*n})
    }

    ## Determines which member of a vector are greater or equal to
    ## the min and strictly less than min + width
    ## boundLimit :: Numeric -> [Numeric] -> numeric -> [bool]
    boundLimit<-function(min,vector,width){
        f<-cbind(function(x){x>=min},
                 function(x){x<min+width})
        a<-lapply(f,function(f)f(vector))
        unlist(a[[1]]==a[[2]])
    }

    ## Splits the data vector into a set of bounds, the bound size is
    ## defined by f
    defineRegions<-function(boundFun,f,steps,data){
        bounds<-getBounds(f,data)
        range<-bounds$max-bounds$min
        iter<-range/steps
        x<-seq(from=bounds$min,to=bounds$max,by=iter)
        lapply(x,boundFun,data,iter)    
    }

    ## takes a list of tags c(A-B,A-B,A-B-C) and returns a logical matrix
    ## ret<-matrix(TRUE TRUE FALSE TRUE TRUE FALSE TRUE TRUE TRUE,ncol=3)
    ## names(ret)<-c("A","B","C")
    tagToMatrix<-function(tags){    
        tagLevels=sapply(tags,strsplit,"-")
        cats<-unique(unlist(tagLevels))
        tempMatrix<-matrix(rep(FALSE,length(tags)*length(cats)),
                           ncol=length(cats))
        trans<-seq(length(cats))
        names(trans)<-cats
        tform<-function(x){
            as.numeric(unlist(sapply(x,function(x) trans[x])))
        }
        tf<-sapply(tagLevels,tform)
        swap<-function(x) as.numeric(unlist(tf[x]))
        for (i in seq(length(tags)))
            tempMatrix[i,swap(tags[i])]<-TRUE
        colnames(tempMatrix)<-cats
        return(tempMatrix)
    }

    ## generates a Numerical matrix from the bins generated by
    ## defineRegions and the logical matrix generated from tagToMatrix.
    ## Has the option of normalizing the rows to generate a % contrib plot
    dataMatrix<-function(bins,tagmatrix,sum=FALSE){
        catagory<-function(bd){
            apply(tagmatrix,2,function(x) length(which(bd[x])))
        }
        plMat<-do.call(rbind,lapply(bins,catagory))
        if(sum)
            plMat<-t(apply(plMat,1,function(x) x/sum(x)))
        plMat
    }

    ## Wrapper for the combination of defineRegions with boundLimit,
    ## the boundLimit function may be changed if non uniform limits
    ## are desired (ie only the top percentile or bottom percentile of
    ## the data vector.
    binData<-function(data,limitFun,steps){
        defineRegions(boundLimit,limitFun,steps,data)
    }

    ## Takes in a list of tag values and a function with a n->1 transform
    ## to change the value of the tag. ie tall_p3 -> prima2 or
    ## tall_p3 -> Leukemia can be made by changeing the swapfun. Swapfun can
    ## be any function which takes a single string and returns another Single
    ## string, by default it is pass<-function(string) string
    ## changeTagNames :: Factor chr -> [chr]
    changeTagNames<-function(tags,swapFun){
        tfun<-function(tags)swapLevel(as.character(unlist(tags)),swapFun)
        sapply(tags, tfun)
    }

    ## A wraper combining tagToMatrix and ChangeTagNames, if no changes in
    ## names are desired this can be short circuited
    genTagMatrix<-function(tags,swapFun)
        tagToMatrix(changeTagNames(tags,swapFun))

    ## A utility for get bounds
    fapply<-function(x,y) x(y)

    ## Applies F to data to find the limits of the analysis, returns a
    ## list(max=f[1](data),min=f[2](data))
    getBounds<-function(f,data){
        bounds<-lapply(f,fapply,data)
        names(bounds)<-c("max","min")
        bounds
    }

    
    globalPlotData<-function(data,n,steps){
        bins<-binData(data,upDown(n),steps)
        gdat<-unlist(lapply(bins,function(x) length(which(x))))
        bounds<-getBounds(upDown(n),data)
        steps<-length(gdat)
        x<-seq(from=bounds$min,to=bounds$max, length.out=steps)
        data.frame(data=gdat,x=x)
    }

    cleanTagNames<-function(tags,swapFun){
        tags2<-apply(tags,2,as.logical)
        #colnames(tags2)<-sapply(colnames(tags),swapFun)
        cats<-unique(colnames(tags2))
        test<-do.call(cbind,
                      lapply(cats,
                             function(x)
                                 ors(lapply(which(cats==x),
                                            function(i) tags2[,i]))))        
        colnames(test)<-cats
        return(test)
    }
    
    stackedPlotData<-function(data,n,steps,tmat,swapFun,sum){
        bounds<-getBounds(upDown(n),data)
        bins<-binData(data,upDown(n),steps)
        cleanedTmat<-cleanTagNames(tmat,swapFun)
        plMat<-dataMatrix(bins,cleanedTmat,sum=sum)
        rord<-order(apply(plMat,2,sum))
        catagories<-colnames(plMat)
        steps<-dim(plMat)[1]
        data.frame(
            x=seq(from=bounds$min,to=bounds$max, length.out=steps),
            data=as.numeric(plMat[,rord]),
            cats=factor(unlist(lapply(catagories[rord],rep,steps))
               ,levels=rev(catagories[rord])))    
    }

    ## Uses GGPLOT2 to generate the contributed plot by default
    ## the data will be ploted with the smallest values at the bottom
    ## and the greatest total contributions at the top. In order to change
    ## the order preset the rord variable. Rather than executing the result
    ## it regurns a ggplot object which can be modified downstream before
    ## ploting.
    plotplMat<-function(dt,overideColour=NULL,blank=NULL){
        x<-0 # needed to pass check
        p<-ggplot(data=dt,
                       aes(x,data,fill=dt$cats,order=-as.numeric(dt$cats)))+
                geom_area(position="stack")+
                theme(panel.background=element_blank(),
                      panel.grid.major=element_blank(),
                      panel.grid.minor=element_blank(),
                      panel.border=element_blank(),
                      axis.title.y=element_blank()) +
                scale_y_continuous(breaks=NULL)
                
                
        if(! is.null(overideColour)){
            print(levels(dt$cats))
            print(overideColour(levels(dt$cats)))
            p<-p+scale_fill_manual(values=overideColour(levels(dt$cats)),name="Cell Conditions")
        }        
        else
            p<-p+scale_fill_discrete(name="Cell Conditions")
        print(blank)
        if(! is.null(blank)){
            p<-p+theme(legend.position="none",axis.title.x=element_blank(),plot.margin=unit(c(0,0,-.5,-.5),"cm"))+scale_x_continuous(breaks=NULL)
        }
        else
            p<-p+scale_x_continuous(name="Principle Component Value")
        p
    }

    plotGlobal<-function(dt){
        dt<-data.frame(x=dt$x,data=dt$data) # required to pass check
        ggplot(data=dt,aes(x=x,y=data))+
        geom_area(position="stack")+
        theme(panel.background=element_blank(),
              panel.grid.major=element_blank(),
              panel.grid.minor=element_blank(),
              panel.border=element_blank(),
              axis.title.y=element_blank()) +
        scale_y_continuous(breaks=NULL) +
        scale_x_continuous(name="Principle Component Value")
    }

    norm<-function(data){
        (data-mean(data))/sqrt(var(data))      
    }
    if(!(requireNamespace("ggplot2")))
        stop("Requires ggplot2")
    switch(command,
           "hist"= plotGlobal(globalPlotData(data,n,steps)),
           "contrib"=plotplMat(stackedPlotData(data,n,steps,genTagMatrix(tags,swapFun),swapFun,sum)),
           "contrib2"=plotplMat(stackedPlotData(norm(data),n,steps,tags,swapFun,sum),colourOveride,blank),
           "tagToMat"=genTagMatrix(tags,swapFun))
}
